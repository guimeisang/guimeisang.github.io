[{"title":"最近的一点思考","date":"2018-09-22T16:16:00.000Z","path":"2018/09/23/最近的一点思考/","text":"26岁了，是时候去删除一些东西，去做一些有效的事情，和有的是时间的人有点不太一样了； 最近离开ENOW团队让别人很难理解，归结两点：1. 长期做项目管理不是我想要的，技术得不到管理；2. 我希望有一个自己的团队，能够和他们一起成长，能够和他们一起开心做一些事情；但是ENOW团队已经不是了； 自己这边因为买房和结婚借了很多钱，很多事情都无法开始，宝宝也出生了；我希望自己能够在3年之后在广州整一套自己的房子和一辆车子，并且一些存款即可；然后有一个称心的团队； 还有就是和老婆的争吵让我无比烦恼，有的时候觉得还不如彼此分开；这样也许不会那么闹心；不然真的很烦；总是听到一些抱怨，总是在反馈一些不好的事情，总是没有看到自己去做改变，总是….. 婚姻，事业，资产，身体总是需要不断的去积累好的因素才能过好这一切，还是不能丧气….. 找一些优秀的人才，组建一个高产的团队，那就是赢，细细的去经营；总会有好的结果出来，年轻的时候苦点没啥的；","tags":[{"name":"思考","slug":"思考","permalink":"https://guimeisang.github.io/tags/思考/"}]},{"title":"react编程思想","date":"2017-08-15T01:47:02.000Z","path":"2017/08/15/react编程思想/","text":"在我的理解中，React是JavaScript构建大型，高性能Web应用的最佳选择。 React很重要的部分是思考如何构建应用程序。 首先我们会有一个JSON API。并且从UI那边得到UI图稿。 步骤1: 将UI拆解到组件层次结构中 就是将需求文档，拿到的时候，对其进行分解。其中要遵循“单一职责原则”。即在理想情况下，一个组件只处理一件事。 如下组件结构： a a-1 a-2 a-3 a-3-1 a-3-2 a-3-3 步骤2: 用react构建一个静态版本 有了你的组件层次结构，就可以去实现静态app。注意在实现的过程中只先实现一个渲染ui无交互效果的版本。并且不能在过程中使用state，因为要知道state只能用于交互中。用Props，组件的属性进行传值就好。 确定UI state的最小但是完整的表示 如果说你想你的app能够交互，那么你需要触发底层的数据模型。React通过state可以实现。 具体策略就是： 先将所有可能的数据list出来（新手推荐）； 分析每一个数据，按照下面三个标准来确定是不是state； 是否可以通过父组件Props传值； 是否永远不发生变化； 是否可以通过state，props计算出来； 最终确定state（状态）是哪几个； 确定state(状态)在哪个组件中 React单向数据流在层级中自上而下，需要判断出状态属于哪个组件。 具体策略： 确定每个需要基于state(状态)渲染的组件； 找出公共的父组件； 如果找不出公共父组件，可以创建一个简单的新组件保留这个state(状态) 添加反向数据流 app已经有Props(属性)和state(状态)沿着层次结构向下传播，但是我们希望一下交互也可以改变state(状态)；但是组件只能更新自己的state（状态），所以我们应该在公共父组件那边去更新，然后将传递到改组件中；在公共父组件中使用下面代码： 12345handleFilterTextInput(filterText) &#123; this.setState(&#123; filterText: filterText &#125;)&#125; 总结有的时候你可能会多写几行代码，但是切记阅读代码的重要性远远高于写代码，模块化，结构清晰的代码最利于阅读，特别是项目比较大的时候。","tags":[{"name":"react 入门思考","slug":"react-入门思考","permalink":"https://guimeisang.github.io/tags/react-入门思考/"}]},{"title":"require和import的理解","date":"2017-08-11T09:39:12.000Z","path":"2017/08/11/require和import的理解/","text":"本文作者：guimeisang，未经同意，禁止转载 以时间为维度，分为ES6之前和ES6之后。其实为了实现javascript的工程化，才引出模块化这个概念，require，import就是为实现这个而生。 在ES6之前在ES6之前引入了模块的概念，主要是为了适应大型应用的。node的module遵守CommonJS规范。而在浏览器端，requirejs和seajs之类的工具包也出现了。所以说在node端，浏览器端。require + module.exports基本实现了所有模块化的编程。 node的module遵循CommonJS规范，requirejs遵循AMD，seajs遵循CMD，虽然各有不同，但代码风格相似。 下面是模块导出端： 12345678910111213141516171819202122// demo1.js// ---- node ----module.exports = &#123; a : function() &#123;&#125;, b : 'foo'&#125;// ----- 浏览器 AMD 和 CMD -----define(function(require, exports, module)&#123; module.exports = &#123; a : function() &#123;&#125;, b : 'foo' &#125;;&#125;);// ------ UMD ------define(function()&#123; return &#123;&#125;; // return 的值就是导出的模块 &#125;); 可以看出来，为了代码风格相似，浏览器端的模块中要使用一个define函数来提供模块的闭包以外，其他代码可以完全一致。 下面是导入模块： 1234567891011// demo2.js// ---- node -----var m = require('./demo1');m.a();// ---- AMD or CMD ----defined(function(require, exports, module)&#123; var m = require('./a'); m.a();&#125;) node发布的时候，就天生具备module，node相当于促进了js世界里面的模块化编程。 注意：exports是module.exports的“别名”，即exports是module.exports地址的引用。 ES6发布之后ES6没有把require写入标准，所以其还是一个普通的函数，ES6使用import指令引入模块或模块中的部分接口。而导出的话，ES6标准中，用export指令，也就是说，module.exports只是node，requirejs等模块化库中的自定义变量，而非ES标准接口。 模块导出下面是导出模块的部分：1234567891011export function a()&#123;&#125;;export &#123; name1, name2, ..., nameN &#125;;export &#123; variable1 as name1, variable2 as name2, ..., nameN &#125;;export let name1, name2, ..., nameN;export default expression;export default function(...)&#123;...&#125;;export * from ...;export &#123; name1, name2, ..., nameN &#125; from ...;export &#123; import1 as name1, ..., nameN &#125; from ...; ES6里面，直接把要导出的变量，函数，对象，类等前面加上一个export关键词，错误演示： 123456// 错误演示export 1; var a = 1;export a;function b() &#123;&#125;;export b; 这种直接内容，而不是导出变量绝对是错误的，或者说导出表达式也是错误的。导出接口仅限两种： 声明时导出； 以对象的形式导出（和解构联系起来）； 如果要导出某个变量，可以如下导出： 1234var a = 1;export &#123;a&#125;; // 解构，相当于&#123;a: a&#125;function b()&#123;&#125;;export &#123;b&#125;; 敲黑板，划重点： ES6最厉害的地方在于，可以在export变量之后，继续修改变量。 1234export cosnt a = 0;a = 1;// 在import之后，发现a的值为1，这个是CommonJS不能做到的。 模块导入 和node之前的require不一样，require只能把模块放到一个变量中，而在ES6中，拥有对象解构赋值的能力，所以直接就把引入的模块接口赋值给变量了。内在机理也不同，require需要执行整个模块，就是将整个模块放到内存中（也就是我们说的在运行时），如果只是用到里面一个方法，性能上就差很多，而import…from，则只需要在编译的时候将需要的接口方法加载，其他的方法在程序启动之后根本触及不到，所以被称为在编译时，性能上有很大的改善。 as 关键词简单来说就是一个别名。export和import都可以用。 123456789// demo1.jsvar a = function() &#123;&#125;; export &#123; a as fun &#125;// demo2.jsimport &#123; fun as a &#125; from &apos;./demo1&apos;;a(); 上面代码中，demo1.js中，以fun代替a这个函数，所以在外面的模块中只能识别到fun，识别不到a。而在demo2.js中，引入fun方法，但是我们用a去代替它。（这有个好处就是，比如demo3.js也导出一个fun的接口，这个时候这个别名就很有用。可以解决这种接口重名的问题） default 关键词简单来说就是别名的语法糖。 123456// demo1.jsexport default function() &#123;&#125;// 等效于function a() &#123;&#125;export &#123;a as default&#125; 在导入的时候： 123import a from &apos;./demo1&apos;;// 等效于import &#123;default as a&#125; from &apos;./d&apos;; * 符号简单来说，*代表所有，看下面的两个例子： 1import * as foo from &apos;_&apos;; 意思是：将’_’模块中所有接口挂载在foo对象上，所以可以用underscore.each调用某个接口。 12345export * from &apos;_&apos;;// 等效于import * as all from &apos;_&apos;;export all; 怎么用require和import这两兄弟？总体感觉，既然ES6将import加入到标准了，这个时候一般还是乖乖的用import的吧。虽然说现在引擎还不能支持import，依然是用bable神器解析成reqiure，所以现在你会发现有些之前的CommonJS模块，依然可以用import引用。 12345// demo1.jsmodule.exports = &#123;&#125;;// demo2.jsimport a from &apos;./demo1&apos;; 这种混搭不是很好，但是可以用。 不过现在不是所有的环境都支持import，所以可以使用babel让node支持ES6，但是浏览器端，则毫无办法，可能暂时用require。但是很遗憾你ES6并不兼容require，所以到时候你必须要升级代码。 import只能在文件开头使用，在import之前，你不能有其他的代码，这和其他语言是一样的。但是require则不同，它相当于node的一个定义在全局的函数，你可以在任意地方使用它，甚至使用变量表达式作为它的参数，这样有一个好处，就是可以在循环中加载模块。 最后说一句，js引擎们很快就会实现ES6标准规定，如果时一个引擎标准都没办法实现，就会被淘汰，所以尽在去部署import，你未来可能改的代码越少。","tags":[{"name":"ES6 require import 模块","slug":"ES6-require-import-模块","permalink":"https://guimeisang.github.io/tags/ES6-require-import-模块/"}]},{"title":"location和分环境开发","date":"2017-05-19T09:29:34.000Z","path":"2017/05/19/location和分环境开发/","text":"Location对象 Location 对象包含有关当前URL的信息。 Location 对象是Window对象的一部分，可通过window.location属性来访问。 对象属性（可以获取和设置）： hash：#后面的部分； host：主机名和端口； hostname: 主机名； href：完整的url； pathname: url路径名； port：url服务器使用的端口号； protocol：协议（http,https）; search：从问号（？）开始的URL（查询部分）； 对象方法 assign() 重新加载文档； reload() 重新加载当前文档； replace() 用新的文档替换当前文档； 在开发中一般会有dev,test,pre,master四种分支，所以接口也会有四种不同的形式，这个时候就可以根据location来做。根据不同路径进行判断不同的环境！ 123456789101112131415161718192021222324252627var loaction_origin = location.origin;var API_ENV = &#123; DEV:&apos;http://dev.abc.com/api&apos;, TEST:&apos;http://test.abc.com/api&apos;, PRE:&apos;http://pre.abc.com/api&apos;, MASTER:&apos;http://abc.com/api&apos;&#125;var FE_ENV=&#123; DEV:&apos;http://dev.abc.com&apos;, TEST:&apos;http://test.abc.com&apos;, PRE:&apos;http://pre.abc.com&apos;, MASTER:&apos;http://dec.abc.com&apos;&#125;var API_URL = API_ENV.DEV;if(location.href.indexOf(FE_ENV.TEST) &gt; -1)&#123; API_URL = API_ENV.TEST;&#125;else if(location.href.indexOf(FE_ENV.PRE) &gt; -1)&#123; API_URL = API_ENV.PRE;&#125;else if(location.href.indexOf(FE_ENV.MASTER) &gt; -1)&#123; API_URL = API_ENV.MASTER;&#125;// 一般都会将该段代码放在common.js里面，配置了这个每次切换环境就不需要每次都改了。","tags":[{"name":"location 环境配置","slug":"location-环境配置","permalink":"https://guimeisang.github.io/tags/location-环境配置/"}]},{"title":"优雅实现ueditor二次开发·自定义事件event","date":"2017-04-20T04:44:21.000Z","path":"2017/04/20/优雅实现ueditor二次开发·自定义事件event/","text":"ueditor优雅的实现方式，并且功能多样，性能不错。当然我们在使用ueditor进行二次开发的时候，会遇到很多它没有的功能。下面就是主要介绍怎么去优雅的二次开发ueditor。自定义事件event 需求场景： 在二次开发插件时，会发现有些地方，有些地方需要自定一个事件并且对应的函数。（其实回顾一下前端开发，都是各个事件组成，并且在这个事件发生时特定去做什么，这样就可以完成一般的需求了！） ueditor的关于事件的设计（_src\\core\\EventBase.js中） 可以先去下载ueditor项目的\\_src\\core\\EventBase.js中看下源码 提炼一下就是： 不得不说下注释： 1234567891011121314151617181920212223242526272829/** * UE采用的事件基类 * @file * @module UE * @class EventBase * @since 1.2.6.1 */ /** * UEditor公用空间，UEditor所有的功能都挂载在该空间下 * @unfile * @module UE */ /** * UE采用的事件基类，继承此类的对应类将获取addListener,removeListener,fireEvent方法。 * 在UE中，Editor以及所有ui实例都继承了该类，故可以在对应的ui对象以及editor对象上使用上述方法。 * @unfile * @module UE * @class EventBase */ /** * 通过此构造器，子类可以继承EventBase获取事件监听的方法 * @constructor * @example * ```javascript * UE.EventBase.call(editor); * */ /** * 注册事件监听器 * @method addListener * @param { String } types 监听的事件名称，同时监听多个事件使用空格分隔 * @param { Function } fn 监听的事件被触发时，会执行该回调函数 * @waining 事件被触发时，监听的函数假如返回的值恒等于true，回调函数的队列中后面的函数将不执行 * @example * 123456789101112* editor.addListener('selectionchange',function()&#123;* console.log(\"选区已经变化！\");* &#125;)* editor.addListener('beforegetcontent aftergetcontent',function(type)&#123;* if(type == 'beforegetcontent')&#123;* //do something* &#125;else&#123;* //do something* &#125;* console.log(this.getContent) // this是注册的事件的编辑器实例* &#125;)* * @see UE.EventBase:fireEvent(String) */ 123456789第一个注释：解释这个文件的作用，并且从所属的模块，类名，第几个版本开始存在。 第二个注释：解释公共空间。 第三个注释：解释关于继承该类，从而获得方法的方式。Editor和ui实例都继承了该类。 第四个注释：解释这个一个构造器，UE.EventBase.call(editor); 第五个注释：解释注册事件监听器，包含了参数解释，例子；- 设计思想： 先构造一个类： var EventBase = UE.EventBase = function () {};1对该类添加事件： EventBase.prototype = { addListener：function(types,listener){}, on:function(types,listener){}, off:function(types,listener){}, trigger:function(){}, removeListener:function(types,listener){}}12345也就是说可以添加事件，也可以移除事件，另外就是触发事件。 **二次开发中需要添加事件和触发事件**使用上面提供的方法，先定义事件，后触发事件。这样在二次开发中就可以自如对应事件，且比较优雅。 / @example@addListener 在加载js之前自定义事件 @fireEvent 在合适的时候触发事件*/editor.addListener(‘beforeevent’,function(){ console.log(‘beforeevent’);}) editor.fireEvent(‘beforeevent’);```","tags":[{"name":"ueditor二次开发 自定义事件event","slug":"ueditor二次开发-自定义事件event","permalink":"https://guimeisang.github.io/tags/ueditor二次开发-自定义事件event/"}]},{"title":"优雅实现ueditor二次开发·自定义UE.plugins&&execCommand()方法","date":"2017-04-18T03:42:22.000Z","path":"2017/04/18/优雅实现ueditor二次开发·自定义UE-plugins-execCommand-方法/","text":"ueditor优雅的实现方式，并且功能多样，性能不错。当然我们在使用ueditor进行二次开发的时候，会遇到很多它没有的功能。下面就是主要介绍怎么去优雅的二次开发ueditor。 自定义UE.pluginsueditor会将一些属性和方法都绑定在命名空间上，一般会将UE，editor，ue绑定在window下面，所以我们在ueditor demo控制命版上就可以看到UE的结构。如下图： 在二次开发中，一般的思路是先定义方法，然后就是使用该方法。可以在图中看到UE下面有plugins对象，里面包括后退，恢复，设置行高等方法，如下图： 如果在二次开发中，成功添加添加plugins之后，能够在控制平台plugins对象中看到我们自定义的方法，说明添加成功！ 体现优雅：可以在在另外一个文件夹中（取名“_custom_example”），把一些需要自定的js，css文件放置在其中，有利于后期维护（建议不要改动源码，除非实在没办法）;文件里面的注释也是必不可少的，比如：文件名称，文件版本，文件中方法，方法的参数，方法的返回等；注意： 在页面记得引入改js文件，并且在editor.all.min.js之后； 比如添加全选功能，并且alert(‘已经全选了’),即使它原来有改方法也没有关系，因为直接可以覆盖掉！ 12345678910111213141516171819202122232425/** * selectall(全选) * @file selectall.js * @description 覆盖 selectall 插件 * @method editor.execCommand( &apos;selectall&apos; ); * @result 全选选取的内容 */ UE.plugins[&apos;selectall&apos;] = function () &#123; var me = this; me.commands[&apos;selectall&apos;] = &#123; execCommand: function() &#123; var me = this, body = me.body, range = me.selection.getRange(); var pgBodys = body.getElementByTagName(&apos;p&apos;);/*选中什么标签，看下你的editor编辑页面有哪些dom*/ range.setStartAtFirst(pgBodys[0].firstChild).setEndAtLast(pgBodys[pgBodys.length-1].lastChild) &#125;, notNeedUndo: 1 &#125;; // 快捷键 me.addshortcutkey(&#123; &quot;selectAll&quot;:&quot;ctrl+65&quot; &#125;); &#125; 这样就算定义完selecall的模块，相当于已经可以使用editor.execCommand(‘selectall’)；","tags":[{"name":"ueditor二次开发，ueditor自定义plugins和execCommand方法","slug":"ueditor二次开发，ueditor自定义plugins和execCommand方法","permalink":"https://guimeisang.github.io/tags/ueditor二次开发，ueditor自定义plugins和execCommand方法/"}]},{"title":"printThis体验","date":"2017-04-18T02:18:48.000Z","path":"2017/04/18/printThis体验/","text":"jQuery pringting plugin; print specific elements on a page;自定义打印的jQuery插件 1234567891011121314151617$(&quot;#mySelector&quot;).printThis(&#123; debug: false, // show the iframe for debugging importCSS: true, // import page CSS importStyle: false, // import style tags printContainer: true, // grab outer container as well as the contents of the selector loadCSS: &quot;path/to/my.css&quot;, // path to additional css file - use an array [] for multiple pageTitle: &quot;&quot;, // add title to print page removeInline: false, // remove all inline styles from print elements printDelay: 333, // variable print delay; depending on complexity a higher value may be necessary header: null, // prefix to html footer: null, // postfix to html base: false , // preserve the BASE tag, or accept a string for the URL formValues: true, // preserve input/form values canvas: false, // copy canvas elements (experimental) doctypeString: &quot;...&quot;, // enter a different doctype for older markup removeScripts: false // remove script tags from print content&#125;); 坑点： css的样式，可以采用媒体查询设置打印的样式， @media print {…} 可以同事打印几个dom 12345$(&apos;#kitty-one, #kitty-two, #kitty-three&apos;).printThis(&#123; importCSS: false, loadCSS: &quot;&quot;, header: &quot;&lt;h1&gt;Look at all of my kitties!&lt;/h1&gt;&quot;&#125;);","tags":[{"name":"jQuery插件","slug":"jQuery插件","permalink":"https://guimeisang.github.io/tags/jQuery插件/"}]},{"title":"页面dom的绑定js事件对应的代码位置","date":"2017-04-08T10:09:42.000Z","path":"2017/04/08/页面dom的绑定js事件对应的代码位置/","text":"页面dom的绑定js事件对应的代码位置背景：平时我们在调试的时候想知道页面上的某一个dom上绑定了什么事件以及绑定代码的位置，下面就介绍三种跟踪页面dom的事件的方法。 使用firefox调试。我们可以使用firefox的debug工具，找到指定的元素，然后查看事件面板 使用chrome调试。在检查的元素上查看面板，在EventListeners标签，可以看到相关事件的绑定信息，点击相应的文件可以跳转到事件定义代码在文件中的位置。 使用chrome web store中的Visual Event检查事件绑定信息上面两个方法，当我们定位事件代码的位置时，如果我们使用js库（比如jquery）的话，调试工作会变得复杂，程序往往会讲我们引导到jquery库中，这样的话仍然是不方便找到哪个文件中addEventListener的事件、这样就可以安装Visual Event。安装完 Visual Event 后，工具条上会有 Visual Event 的图标。然后打开我们要调试的页面，在工具栏上点击他那个火眼金睛一样的眼睛图标，网页上所有绑定了事件的 HTML 元素都会由一个半透明的蓝色遮罩层覆盖，鼠标移动到相应的元素上即可看到事件绑定信息。刚才说了，在使用了Js 库的时候，visual event 依然很好用，下面列出它支持的几个库的名字及版本信息： 获取Visual Event： VisualEvent 在GitHub上的位置 ：https://github.com/DataTables/VisualEvent VisualEvent 在Chrome webstore 上的位置：https://chrome.google.com/webstore/detail/visual-event/pbmmieigblcbldgdokdjpioljjninaim 如果都没有办法，则需要在js文件中不断的debug和梳理js逻辑","tags":[]},{"title":"angular中ng-show和ng-if的微妙区别","date":"2017-04-08T10:09:12.000Z","path":"2017/04/08/angular中ng-show和ng-if的微妙区别/","text":"场景：最近在使用插件时，发现如果是使用ng-if时，jquery很有可能获取不到这个元素。但是ng-show是可以获取到的。 分析：可能ng-if不会在页面进入的时候渲染。只有在条件符合的时候才会去触发；但是ng-show会在页面渲染的时候就会渲染，所以在使用插件的时候，ng-show可以直接获取到这个dom","tags":[{"name":"angular","slug":"angular","permalink":"https://guimeisang.github.io/tags/angular/"}]},{"title":"js控制滚动条的位置","date":"2017-04-08T10:08:45.000Z","path":"2017/04/08/js控制滚动条的位置/","text":"场景： 控制dom元素内的滚动条，需要控制滚动条的位置。 HTML1234567891011&lt;div class=&quot;scroll-wrap&quot; style=&quot;overflowY:scroll&quot;&gt; &lt;div id=&apos;div1&apos;&gt;1&lt;/div&gt; &lt;div id=&apos;div2&apos;&gt;2&lt;/div&gt; &lt;div id=&apos;div3&apos;&gt;3&lt;/div&gt; &lt;div id=&apos;div4&apos;&gt;4&lt;/div&gt; &lt;div id=&apos;div5&apos;&gt;5&lt;/div&gt; &lt;div id=&apos;div6&apos;&gt;6&lt;/div&gt; &lt;div id=&apos;div7&apos;&gt;7&lt;/div&gt; .... &lt;div id=&apos;div100&apos;&gt;100&lt;/div&gt;&lt;/div&gt; js123(function($)&#123; $(&apos;div.scroll-warp&apos;).scrollTop = $(&apos;#div50&apos;).offsetTop;&#125;)(); 注意这样的话可以通过计算得到需要移动的距离，具体可以参考下面这个图","tags":[{"name":"js小效果","slug":"js小效果","permalink":"https://guimeisang.github.io/tags/js小效果/"}]},{"title":"移动端打印调试介绍","date":"2017-04-08T10:08:28.000Z","path":"2017/04/08/移动端打印调试介绍/","text":"移动端打印调试介绍-debug.js在移动端，js调试。alert的手段在简单的调试中还是蛮有效的，但是alert会将输出的对象toString()方法，这样有些对象alert就会有”[object object]”的字样。还有另外一个方法就是debug.js。debug.js会将调试信息显示在网页上，其实原理也十分简单，就是动态的创建DOM元素，然后append到页面上。使用方法很简单，现在页面上引入debug.js，然后用它的debug.log API，跟console.log用法一样一样的。 123456789&lt;iframe src=&apos;http://www.cnblogs.com&apos; style=&apos;width:100%; height:100%&apos;&gt; &lt;/iframe&gt;&lt;script src=&quot;debug.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var a = &#123;name: &apos;hanzichi&apos;, age: 10&#125;; debug.log(a); var b = [1, 2, 3]; debug.log(b);&lt;/script&gt; 触碰下调试信息，它就会隐藏掉。 debug.js GithubDEBUG.COFFEE 使用fiddler代理调试本地手机页面 在调试移动端页面上时，虽然90%的功能都能用chrome下的模拟器来模拟解决，但是剩余的10%却只能在真机上调试。比如一两个像素的误差，比如说只有真机上才能重现一些bug，所以用fiddler来调试本地页面。 首先就是安装fiddler，然后按照下图进行配置fiddler： 其次在手机上长按wifi，按照下图进行配置： 调试： 接下来就可以用手机浏览器调试本地页面了，但是还是有几点要注意： 在本地搭建好服务器后，不能用 localhost 在移动端进行访问，也不能用 127.0.0.1。可以随便绑定一个地址，比如 127.0.0.1 www.cnblogs.com（hosts 文件中，如果之前修改了 vhosts 文件，那么 vhosts 文件也要一并修改） 我手机上有 4 个浏览器，uc、chrome、2345以及百度，前三个都能得到预想的结果，但是百度浏览器不知道为何却不能重定向。有时候不行的话或者可以试试别的浏览器，对我而言一个浏览器能出结果就已经 ok 了。 如果浏览器安装了代理插件，禁用代理插件或改为系统代理，否则 fiddler 捕捉不到请求","tags":[{"name":"移动端 调试","slug":"移动端-调试","permalink":"https://guimeisang.github.io/tags/移动端-调试/"}]},{"title":"201703angular1.3父子通信","date":"2017-03-28T04:52:03.000Z","path":"2017/03/28/201703angular1-3父子通信/","text":"Angularjs 利用 $on、$emit和$broadcast传值$emit只能向父controller传递event与data$scope.$emit(“参数名称”,参数值); $broadcast只能向子controller传递event与data $scope.$broadcast(“参数名称”,参数值); $on用于接收event与data$scope.$on(“参数名称”,function(e,data){ console.log(data);}); 利用$watch监听模型变化$watch是一个scope函数，用于监听模型变化，当你的模型部分发生变化时它会通知你。 $watch(watchExpression, listener, objectEquality);每个参数的说明如下： watchExpression：监听的对象，它可以是一个angular表达式如’name’,或函数如function(){return $scope.name}。 listener: 当watchExpression变化时会被调用的函数或者表达式,它接收3个参数：newValue(新值), oldValue(旧值), scope(作用域的引用) objectEquality：是否深度监听，如果设置为true,它告诉Angular检查所监控的对象中每一个属性的变化. 如果你希望监控数组的个别元素或者对象的属性而不是一个普通的值, 那么你应该使用它 1234567var watch = $scope.$watch(&apos;被监听模型&apos;,function(newValue,oldValue, scope)&#123; console.log(newValue); console.log(oldValue);&#125;);","tags":[{"name":"angular 1.3 父子通信技术总结","slug":"angular-1-3-父子通信技术总结","permalink":"https://guimeisang.github.io/tags/angular-1-3-父子通信技术总结/"}]},{"title":"201703前端和UI合作规范的一些想法","date":"2017-03-28T04:49:58.000Z","path":"2017/03/28/201703前端和UI合作规范的一些想法/","text":"前端、UI岗位合作规范总结和建议目的：为了前端和UI合作顺畅，工作内容界限清晰！为了UI问题前置，缩减整个开发周期的时间! 切图： 一个页面top,banner,nav,content,foot按区域分类切图！并放置在不同的文件夹。 部分功能的切图，也可以单独分为一个文件夹； 切图一般要注意涵盖icon，不规则背景图等（这些是前端经常写页面是需要的）； 批注： 整体风格和习惯（重要）：任何修改更新到psd，不接受口头通知前端，录到worktitle；bug请录到work云上（请区别好bug和更新修改！bug代表的只是没有按照psd文档来做的。请不要混杂修改，更新！）；效果图必须评审可执行性！所有页面必须有一个比较合理，确定的风格（避免多频率的返工）；有些页面在没有数据时的样式，数据过多，内容过多的样式（重要，这个最容易忽视！！！） 注意部分地方有不同状态下（划过，选中，默认）的样式； 多做注释！！！ 整体页面：宽高，边框，边间距； 字：字体，大小，颜色，是否加粗，是否斜体（若要其他效果请特别标明！）； 边框：宽度，形式（虚线还是实线），颜色，圆角半径（若要其他效果请特别标明！）； 背景：颜色，图案在当前框内的位置，是否重复填充； 间距：以左上角为原点，进行标注间距； 实例： 注意：合作规范会随着团队不断合作，出现新的问题而更新","tags":[{"name":"前端和UI合作规范","slug":"前端和UI合作规范","permalink":"https://guimeisang.github.io/tags/前端和UI合作规范/"}]},{"title":"201703前后端","date":"2017-03-28T04:46:38.000Z","path":"2017/03/28/201703前后端/","text":"情景模式：很多次和后端调参的时候，发现自己效率很低，这个问题导致了自己没什么时间去调试和优化自己的前端代码，每次上线前都基本上没有精力去做代码优化。 先给自己提几个问题吧 是业务不太熟悉，或者是在脑海中没有形成业务闭环； 传参错误的次数好像还是很多，为什么会这么多，怎么减少？ 前后端调试，如果是我能学会测试的技能，就可以提高一部分调试的准确性，可以在通知后端之前就把错误定位好 前期我真正需要向后端知道的数据是什么？ 前期需要准备什么才能顺利开展工作，中期如何克制自己的情绪才能稳定对接，后期如何鼓励自己优化代码；这些都是自己的不足之处 先给出怎么样才能不需要强依赖后端去为我们造数据 先举个例子：在制作列表页面的交互的时候，页面都是依赖于数据进行展示的，列表中的资源是有不同的状态，里面的不同的状态来显示不同的交互已经页面，所以在有强依赖于业务逻辑，并且后端此时没有时间去帮助造数据。 这个是需要造数据。这是一个json格式的数据，也就是仿照后端返回的数据结构来写的，然后通过改里面的数据来控制状态，从而显示不同的交互。然后在fiddler里面设置规则，监听如果是跳去这个接口的时候则更换返回的json数据即可，这样的话，这样就可以自动的造数据，造我们需要的数据这样就可以有我们想要的假数据，这就完全能够满足我们写样式时的需求了。 总结： 这个方法，需要后端不仅要给出接口，还要给出这个接口对应的数据结构。 怎么去理解后端接口的问题 首先，前端需要的数据，可以分类，一种是前端展示的数据，这种是没那么重要的参数。再次就是用来交互，业务做为判断条件的参数。这些至关重要。 接到一个业务的时候，首先应该考量的是那些业务我是需要后端传参过来我才能判断的交互，或者说业务逻辑 其次的话，就是后端需要的数据。首先前端接到一个业务的时候，先判断的是字段之间关系，理清了关系之后再写代码，评估数据结构的关系，再次得是显示的字段（这是最为其次的东西），后端的接口，为什么需要前端传参，因为后端需要前端的传参，来作为判断条件，所以参数一定不要出问题 怎么定位问题当出现一个系统异常的时候，可以看后端的日志，来判断是前端传参错误还是后端的错误。当然也可以通过去前端服务器看错误日志：先连接服务器————&gt; cd /usr/local/run/tomcat-test/logs/quetion-logs然后在这个文件夹中，打开tail -f springmvc.2017-03-01.log 就可以查看一波到底是前端的问题，还是后端的问题。 现在后端的接口调错工具命令： less catalina-daemon.out位置： /data/tomcat-dev/logs","tags":[{"name":"前后端分离问题总结","slug":"前后端分离问题总结","permalink":"https://guimeisang.github.io/tags/前后端分离问题总结/"}]},{"title":"上传头像插件","date":"2017-01-18T09:18:47.000Z","path":"2017/01/18/上传头像插件/","text":"上传头像插件目的： 帮助开发者快速开发上传头像功能点 背景： 现在b，g能搜到的头像上传插件并不太好用，所以想提供一个比较自由度的上传并且可以剪切的插件。 资源： 具体资源请查看这里 实现大致思路如下： 先有一个上传的（本地上传的功能），然后获取图片的地址。 获取图片地址之后，进行截取图片（这里推荐一个插件）点这里，具体怎么用就不再赘述。 等截取图片之后，需要将截取的文件转换为二进制大文件。$(‘#image’).cropper(‘getCroppedCanvas’).toBlob(); 调取接口，将二进制大文件上传即可。 直接上代码吧： 先引入如下文件 1cropper.js [点这里](https://github.com/fengyuanchen/cropperjs) 具体业务代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188$(function () &#123; var URL = window.URL || window.webkitURL; var $image = $(&apos;#image&apos;); var $rotate = $(&apos;#userImg_rotate&apos;); var $reUpload = $(&apos;#userImg_reUpload&apos;); var $zoomOut = $(&apos;#userImg_zoomOut&apos;); var $zoomIn = $(&apos;#userImg_zoomIn&apos;); var $save = $(&apos;#userImg_save&apos;); var croppable = false; var $previews = $(&apos;.userImg_preview&apos;); var options = &#123; aspectRatio: 1, viewMode: 1, built: function () &#123; croppable = true; &#125;, build: function (e) &#123; var $clone = $(this).clone(); $clone.css(&#123; display: &apos;block&apos;, width: &apos;100%&apos;, minWidth: 0, minHeight: 0, maxWidth: &apos;none&apos;, maxHeight: &apos;none&apos; &#125;); $previews.css(&#123; width: &apos;100%&apos;, overflow: &apos;hidden&apos; &#125;).html($clone); &#125;, crop: function (e) &#123; var imageData = $(this).cropper(&apos;getImageData&apos;); var previewAspectRatio = e.width / e.height; $previews.each(function () &#123; var $preview = $(this); var previewWidth = $preview.width(); var previewHeight = previewWidth / previewAspectRatio; var imageScaledRatio = e.width / previewWidth; $preview.height(previewHeight).find(&apos;img&apos;).css(&#123; width: imageData.naturalWidth / imageScaledRatio, height: imageData.naturalHeight / imageScaledRatio, marginLeft: -e.x / imageScaledRatio, marginTop: -e.y / imageScaledRatio &#125;); &#125;); &#125; &#125;; var originalImageURL = $scope.userInfo_imgUrl; var uploadedImageURL; $scope.initCropper = function()&#123; // init $image.attr(&apos;src&apos;,$scope.userInfo_imgUrl).cropper(options); &#125;; // rotate $rotate.on(&apos;click&apos;, function()&#123; $image.cropper(&apos;rotate&apos;, 90); &#125;); // zoomOut $zoomOut.on(&apos;click&apos;,function()&#123; $image.cropper(&apos;zoom&apos;, -0.1); &#125;); // zoomIn $zoomIn.on(&apos;click&apos;,function()&#123; $image.cropper(&apos;zoom&apos;, 0.1); &#125;); // Move /*$move.on(&apos;click&apos;,function()&#123; $image.cropper(&apos;setDragMode&apos;); &#125;);*/ // reUpload $reUpload.on(&apos;click&apos;,function()&#123; $image.cropper(&apos;destroy&apos;).attr(&apos;src&apos;, $scope.userInfo_imgUrl).cropper(options); if (uploadedImageURL) &#123; URL.revokeObjectURL(uploadedImageURL); uploadedImageURL = &apos;&apos;; &#125; &#125;); // Keyboard $(document.body).on(&apos;keydown&apos;, function (e) &#123; if (!$image.data(&apos;cropper&apos;) || this.scrollTop &gt; 300) &#123; return; &#125; switch (e.which) &#123; case 37: e.preventDefault(); $image.cropper(&apos;move&apos;, -1, 0); break; case 38: e.preventDefault(); $image.cropper(&apos;move&apos;, 0, -1); break; case 39: e.preventDefault(); $image.cropper(&apos;move&apos;, 1, 0); break; case 40: e.preventDefault(); $image.cropper(&apos;move&apos;, 0, 1); break; &#125; &#125;); // 剪切和确定上传图片 $save.on(&apos;click&apos;,function()&#123; common.Loading.show(); $(&apos;#image&apos;).cropper(&apos;getCroppedCanvas&apos;).toBlob(function (blob) &#123; var formData = new FormData(); formData.append(&apos;photoFile&apos;, blob); // 这里写入后端给你的上传接口 $.ajax(API_URL+&apos;&apos;, &#123; method: &quot;POST&quot;, data: formData, headers: &#123; &apos;auth-token&apos; : common.Cookie.get(&apos;token&apos;) &#125;, processData: false, contentType: false, success: function (res) &#123; common.Loading.hide(); common.Toast.show(&apos;头像上传成功！&apos;); try&#123; $scope.$apply(function()&#123; $scope.isShowUnCompleteInfoBox = false; $scope.isShowCompleteInfoBox = false; $scope.userInfo_imgUrl = res.data; &#125;) &#125;catch(err)&#123; console.log(err) &#125; &#125;, error: function () &#123; common.Toast.show(&apos;头像上传失败！&apos;); &#125; &#125;); &#125;); &#125;) // 上传图片，这里传本地的图片并且获取一个本地图片的路径 var $inputImage = $(&apos;#inputImage&apos;); if (URL) &#123; $inputImage.change(function () &#123; var files = this.files; var file; if (!$image.data(&apos;cropper&apos;)) &#123; return; &#125; if (files &amp;&amp; files.length) &#123; file = files[0]; if (/^image\\/\\w+$/.test(file.type)) &#123; if (uploadedImageURL) &#123; URL.revokeObjectURL(uploadedImageURL); &#125; uploadedImageURL = URL.createObjectURL(file); $image.cropper(&apos;destroy&apos;).attr(&apos;src&apos;, uploadedImageURL).cropper(options); $inputImage.val(&apos;&apos;); &#125; else &#123; common.Toast.show(&apos;请选择图片再上传！&apos;) &#125; &#125; &#125;); &#125; else &#123; $inputImage.prop(&apos;disabled&apos;, true).parent().addClass(&apos;disabled&apos;); &#125; &#125;);","tags":[{"name":"插件","slug":"插件","permalink":"https://guimeisang.github.io/tags/插件/"}]},{"title":"nodejs批量修改图片名称","date":"2017-01-10T06:14:37.000Z","path":"2017/01/10/nodejs批量修改图片名称/","text":"nodejs批量修改图片名称 有时候UI给我们的图片是自己并不想要的名称，这个时候批量修改图片的作用就显示出来了 首先看下文件目录结构+img(files)+changeName.js 我们要将img文件夹中的图片改成abc1，abc2,…之类名字的图片 然后我们看看changeName.js的内容吧 123456789101112131415161718// 引入fs文件处理模块var fs = require(&quot;fs&quot;);var path = &apos;img&apos;fs.readdir(path, function(err, files) &#123; // files是名称数组 files.forEach(function(filename,index) &#123; //修改图片名称，当然如果只是改名字中一部分也是可以的，用字符串的拼接就好 var oldPath = path + &apos;/&apos; + filename, newPath = path + &apos;/&apos; + &apos;module&apos; + index; //newPath = path + &apos;/&apos; + filename.replace(/aa/g,&apos;bb&apos;); fs.rename(oldPath, newPath, function(err) &#123; if (!err) &#123; console.log(filename + &apos;替换成功!&apos;) &#125; &#125;) &#125;)&#125;) 然后在changName.js的目录下面用命令行运行下node changeName.js 就可以了","tags":[{"name":"nodejs 批量修改图片名称","slug":"nodejs-批量修改图片名称","permalink":"https://guimeisang.github.io/tags/nodejs-批量修改图片名称/"}]},{"title":"给ueditor添加dialog","date":"2017-01-02T02:02:04.000Z","path":"2017/01/02/给ueditor添加dialog/","text":"以添加”guimeisang”按钮为例说明，下面详细讲怎么给UEditor添加自定义弹窗。各位看官看完记得自己写个demo看看咯… 先大概说下UEditor的文件目录 dialogs: 弹出对话框对应的资源和JS文件 lang: 编辑器国际化显示的文件 themes: 样式图片和样式文件 third-party: 第三方插件(包括代码高亮，源码编辑等组件） ueditor.all.js: 开发版代码合并的结果,目录下所有文件的打包文件 ueditor.all.min.js: ueditor.all.js文件的压缩版，建议在正式部署时采用 ueditor.config.js: 编辑器的配置文件，建议和编辑器实例化页面置于同一目录 ueditor.parse.js: 编辑的内容显示页面引用，会自动加载表格、列表、代码高亮等样式 ueditor.parse.min.js: ueditor.parse.js文件的压缩版，建议在内容展示页正式部署时采用 修改ueditor.config.js文件在ueditor.config.js文件中，找到toolbars参数，增加一个“guimeisang”字符串，对应着添加一个labelMap，用于鼠标移上按钮时的提示。123456789101112131415161718//工具栏上的所有的功能按钮和下拉框，可以在new编辑器的实例时选择自己需要的从新定义, toolbars: [[ &apos;fullscreen&apos;, &apos;source&apos;, &apos;|&apos;, &apos;undo&apos;, &apos;redo&apos;, &apos;|&apos;, &apos;bold&apos;, &apos;italic&apos;, &apos;underline&apos;, &apos;fontborder&apos;, &apos;strikethrough&apos;, &apos;superscript&apos;, &apos;subscript&apos;, &apos;removeformat&apos;, &apos;formatmatch&apos;, &apos;autotypeset&apos;, &apos;blockquote&apos;, &apos;pasteplain&apos;, &apos;|&apos;, &apos;forecolor&apos;, &apos;backcolor&apos;, &apos;insertorderedlist&apos;, &apos;insertunorderedlist&apos;, &apos;selectall&apos;, &apos;cleardoc&apos;, &apos;|&apos;, &apos;rowspacingtop&apos;, &apos;rowspacingbottom&apos;, &apos;lineheight&apos;, &apos;|&apos;, &apos;customstyle&apos;, &apos;paragraph&apos;, &apos;fontfamily&apos;, &apos;fontsize&apos;, &apos;|&apos;, &apos;directionalityltr&apos;, &apos;directionalityrtl&apos;, &apos;indent&apos;, &apos;|&apos;, &apos;justifyleft&apos;, &apos;justifycenter&apos;, &apos;justifyright&apos;, &apos;justifyjustify&apos;, &apos;|&apos;, &apos;touppercase&apos;, &apos;tolowercase&apos;, &apos;|&apos;, &apos;link&apos;, &apos;unlink&apos;, &apos;anchor&apos;, &apos;|&apos;, &apos;imagenone&apos;, &apos;imageleft&apos;, &apos;imageright&apos;, &apos;imagecenter&apos;, &apos;|&apos;, &apos;simpleupload&apos;, &apos;insertimage&apos;, &apos;emotion&apos;, &apos;scrawl&apos;, &apos;insertvideo&apos;, &apos;music&apos;,&apos;audio&apos;, &apos;attachment&apos;, &apos;map&apos;, &apos;gmap&apos;, &apos;insertframe&apos;, &apos;insertcode&apos;, &apos;webapp&apos;, &apos;pagebreak&apos;, &apos;template&apos;, &apos;background&apos;, &apos;|&apos;, &apos;horizontal&apos;, &apos;date&apos;, &apos;time&apos;, &apos;spechars&apos;, &apos;snapscreen&apos;, &apos;wordimage&apos;, &apos;|&apos;, &apos;inserttable&apos;, &apos;deletetable&apos;, &apos;insertparagraphbeforetable&apos;, &apos;insertrow&apos;, &apos;deleterow&apos;, &apos;insertcol&apos;, &apos;deletecol&apos;, &apos;mergecells&apos;, &apos;mergeright&apos;, &apos;mergedown&apos;, &apos;splittocells&apos;, &apos;splittorows&apos;, &apos;splittocols&apos;, &apos;charts&apos;, &apos;|&apos;, &apos;print&apos;, &apos;preview&apos;, &apos;searchreplace&apos;, &apos;help&apos;, &apos;drafts&apos;,&apos;guimeisang&apos;]]//当鼠标放在工具栏上时显示的tooltip提示,留空支持自动多语言配置，否则以配置值为准,labelMap:&#123; guimeisang:&apos;桂梅桑&apos;&#125; 修改ueditor.all.js文件找到iframeUrlMap增加一行：1&apos;audio&apos;: &apos;~/dialogs/guimeisang/guimeisang.html&apos;, 找到btnCmds、dialogBtns增加一个元素：guimeisang 接下来在dialogs文件夹下创建guimeisang文件夹并新建guimeisang.html12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;../internal.js&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; *&#123;margin:0;padding:0;color: #838383;&#125; table&#123;font-size: 12px;margin: 10px;line-height: 30px&#125; .txt&#123;width:300px;height:21px;line-height:21px;border:1px solid #d7d7d7;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label for=&quot;href&quot;&gt;桂梅桑blog&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input class=&quot;txt&quot; id=&quot;href&quot; type=&quot;text&quot; /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;script type=&quot;text/javascript&quot;&gt; function handleDialogOk() &#123; if ($G(&apos;href&apos;).value) &#123; var patt1 = /blog/gi; if (patt1.test($G(&apos;href&apos;).value)) &#123; editor.execCommand(&apos;insertHtml&apos;,&apos;博客&apos;) ; dialog.close(); &#125; else &#123; alert(&quot;这不是滴！！！&quot;); return false; &#125; &#125; else &#123; alert(&quot;啥都没有&quot;); return false; &#125; &#125; dialog.onok = handleDialogOk; $G(&apos;href&apos;).onkeydown = function(evt) &#123; evt = evt || window.event; if (evt.keyCode == 13) &#123; handleDialogOk(); return false; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 相关的操作js也写在该html里面。到这里，运行编辑器 新加的按钮已经出来啦，但是点击弹出的窗口样式不对 乱了；这时候，修改themes/default/css/ueditor.css文件，增加一条样式：123.edui-default .edui-for-audio .edui-icon &#123; background-position: -18px -40px&#125; 至此，弹窗可以正常显示了，并能插入相应的代码。","tags":[{"name":"ueditor","slug":"ueditor","permalink":"https://guimeisang.github.io/tags/ueditor/"},{"name":"dialog","slug":"dialog","permalink":"https://guimeisang.github.io/tags/dialog/"}]},{"title":"决定","date":"2017-01-02T02:01:30.000Z","path":"2017/01/02/决定/","text":"最重要的决定时间过得好快…回想谁若过得好，必然是每一个重要的决定都做得很好…中考，高考，买房，结婚，升职，创业等等…这些决定都无不深刻的影响着每一个人的生活…不可忽视这些决定…为做这些决定后面的思考琢磨…为达到这些决定所需要付出的努力…都那么艰难，一个个重要的决定！","tags":[{"name":"2017自白","slug":"2017自白","permalink":"https://guimeisang.github.io/tags/2017自白/"}]},{"title":"拒绝","date":"2017-01-02T02:01:07.000Z","path":"2017/01/02/拒绝/","text":"2016年，自己想要的一年也许上半年，平静和孤独下半年，开始的充实，踏实难题再次出现，时间和精力拒绝不必要的时间浪费，不必要的精力拒绝不必要的那便是成熟","tags":[{"name":"2017自白","slug":"2017自白","permalink":"https://guimeisang.github.io/tags/2017自白/"}]},{"title":"reviewAndPlan","date":"2017-01-02T02:00:38.000Z","path":"2017/01/02/reviewAndPlan/","text":"生活不易，需要多思索才能有收获 2016年去年哪些事情是在浪费自己的时间和精力去年哪些还是可以提高效率去年哪些决定做错了去年哪些…. 2017年 如何实现我进入BAT甚至谷歌、Facebook 、微软的愿景，哪怕是往这个方向再走一步也不错 开始学着拒绝…拒绝浪费自己时间的事情，浪费自己精力的事情 进一步提高自己的效率（工作效率和学习效率） 如何保持信息交流，比我小2岁的人在憧憬什么，比我大两岁的人在担忧什么 重要的决定一定要多琢磨，多思考，早准备；重要的决定一定要多花心思，多花力气完成 如何把计划落地（这是一个费精力和费脑子的活） 自白心态一定要坚定，好习惯才不会那么容易丢失，坏习惯才不会那么容易；生活好难，一直都这么难吗？是的，一直都是这么操蛋的难…从未有轻松的生活，从未有容易的学习，从未有那么容易的恋爱….这都是去年大半年在想的问题…孤独和平静 而今年…拒绝和正确大家时间都是那么多，效率那么的重要…大家精力都那么多，拒绝那么重要…2017，大家都那么长，都那么短。做正确决定那么重要…我好忐忑，我很担心。但我应该不怕，至少我都思考过…一直正确是那么的可贵，好想找到一个这样的人，成熟的思考体系，清晰的逻辑思维，准确的社会见识…好久没遇到这种人，好想再次遇到，期待遇见你当然我也想成为这样的人…可是没那么容易","tags":[{"name":"2017自白","slug":"2017自白","permalink":"https://guimeisang.github.io/tags/2017自白/"}]},{"title":"how to use a new plugin","date":"2016-12-23T02:38:12.000Z","path":"2016/12/23/how-to-use-a-new-plugin/","text":"近期在做公式编辑器，当mathml语言和latex语言之间的转换，渲染方案的选择，还有wiris未知的api,这些都让我这周好疲惫。总在想直接大改，但是许多未知的小问题做起来都十分的困难，很是头疼。都说想做自己的一套公式编辑器，但是真的谈何容易，简单来说，如何将mathml的插入，如何将mathml渲染出来等等，这任何一个都复杂。其实也不是很难，但是需要不断的调试；上午有点心累，想休息下，也来总结下吧 未知插件的使用背景： 有些插件没有将api开放出来，并且给你的代码可能是压缩后的注意点： 每一个插件都会实例化一个对象，插件里面都会将一个api捆绑在这个对象上面，所以当实例化之后，打断点，在这个对象里面去找api是最高效的； 如果工作只是用用api就好了，难度在于需要改造这个插件； 自己构思，如果你来写这个插件，你会怎么来做。 比如改造，首先得看得懂，所以以后要提醒自己写代码的时候，也得带着这种思维去写代码；这样才能提升自己 总之学会调试，合理的猜想，通过实际来验证，排除法…这些知识都需要实践来转变为智慧啊。 总之： 多调试，通过改造提升自己代码能力和思维深化","tags":[{"name":"editor","slug":"editor","permalink":"https://guimeisang.github.io/tags/editor/"}]},{"title":"一种需要返回ID的下拉框插件","date":"2016-12-16T03:59:50.000Z","path":"2016/12/16/一种需要返回ID的下拉框插件/","text":"先看效果 HTML1234567&lt;label class=&quot;self_label_class common_label_class&quot;&gt;&lt;/label&gt;&lt;ul class=&quot;self_ul_class common_ul_class&quot; style=&quot;display:none;&quot;&gt;&lt;/ul&gt;&lt;script src=&quot;./custom/component/component.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./custom/component/dropDown.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./custom/component/demo.js&quot;&gt;&lt;/script&gt; CSS123456.common_label_class&#123;display:inline-block;width:270px;line-height:42px;height:42px;overflow:hidden;font-size:14px;color:#5a5a5a;border:1px solid #e3e3ed;padding:0px 24px 0px 14px;margin-right:8px;background: url(&quot;.&quot;) 278px center no-repeat;&#125;.common_label_class:hover&#123;background: url(&quot;.&quot;) 278px center no-repeat;border:1px solid #98bd31;&#125;.common_label_class.active&#123;background: url(&quot;.&quot;) 278px center no-repeat !important;border:1px solid #98bd31 !important;&#125;.common_ul_class&#123;position: absolute;width:310px;left:-32px;margin-top:-3px;background:#fff;max-height:297px;overflow-y: auto;&#125;.common_ul_class li&#123;font-size:12px;color:#666;padding:0px 14px;line-height:32px;border-bottom:1px solid #cdcdd1;border-left:1px solid #cdcdd1;border-right:1px solid #cdcdd1;background:#fff;cursor: pointer;&#125;.common_ul_class li:hover&#123;background:#f0f0f6;&#125; demo.js123456789101112131415161718192021222324var typeId = null;//这是点击之后返回的值var options = &#123; self_label_class:&apos;self_label_class&apos;, self_ul_class:&apos;self_ul_class&apos;, common_label_class:&apos;common_label_class&apos;, common_ul_class:&apos;common_ul_class&apos;, defaultTxt:&quot;这里写选择框里的内容&quot;, id:&quot;code&quot;, name:&quot;codeValue&quot;, list_data:[ &#123; &quot;code&quot; : 1, &quot;codeValue&quot; : &quot;易错题&quot; &#125;,&#123; &quot;code&quot; : 2, &quot;codeValue&quot; : &quot;典型题&quot; &#125;, &#123; &quot;code&quot; : 3, &quot;codeValue&quot; : &quot;其他&quot; &#125;], callback:function(currentLiId)&#123; typeId = currentLiId; &#125;&#125;;custComponent.dropDown.init(options); 组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// dropDown.js(function(CustomComponent)&#123; var newLi,_ul,currentLi,currentLiId; //初始化组件dom function _init(options)&#123; var name = options.name, id = options.id, list_data = options.list_data, callback = options.callback, defaultTxt = options.defaultTxt, self_label_class = options.self_label_class, self_ul_class = options.self_ul_class, common_label_class = options.common_label_class, common_ul_class = options.common_ul_class, node_label = document.getElementsByClassName(self_label_class)[0], node_ul = document.getElementsByClassName(self_ul_class)[0], all_node_label = document.getElementsByClassName(common_label_class), all_node_ul = document.getElementsByClassName(common_ul_class); node_label.innerHTML = defaultTxt; for(var i=0;i&lt;list_data.length;i++)&#123; newLi = document.createElement(&apos;li&apos;); newLi.innerHTML = list_data[i][name]; newLi.setAttribute(&quot;objId&quot;,list_data[i][id]); newLi.setAttribute(&quot;class&quot;,&quot;dropDown-content-li&quot;); node_ul.appendChild(newLi); &#125; _UlBingClick(node_label,node_ul); _LiBingClick(node_label,node_ul,options,callback); _closeAllDropDown(all_node_label,all_node_ul); &#125;; //点击label显示ul function _UlBingClick(node_label,node_ul)&#123; node_label.onclick = function(event)&#123; if(node_ul.style.display==&quot;block&quot;)&#123; node_ul.style.display=&quot;none&quot;; &#125;else&#123; node_ul.style.display=&quot;block&quot;; &#125; if(event&amp;&amp;event.stopPropagation)&#123; event.stopPropagation(); &#125; &#125; &#125; //点击li并且传值过去 function _LiBingClick(node_label,node_ul,options,callback)&#123; node_ul.onclick = function(event)&#123; currentLi = event.target; if(currentLi.className == &quot;dropDown-content-li&quot;)&#123; _currentLiId = currentLi.getAttribute(&apos;objId&apos;); node_label.innerHTML = currentLi.innerHTML; if(node_label.innerHTML!= options.defaultTxt)&#123; var _className = options.self_label_class +&quot; &quot; + options.common_label_class+&quot; &quot; + &quot;active&quot;; node_label.setAttribute(&apos;class&apos;,_className); &#125;else&#123; var _className = options.self_label_class +&quot; &quot; + options.common_label_class; node_label.setAttribute(&apos;class&apos;,_className); &#125; node_ul.style.display=&quot;none&quot;; callback(_currentLiId); if(event&amp;&amp;event.stopPropagation)&#123; event.stopPropagation(); &#125; &#125; &#125; &#125;; //如果不是点击在ul或者label上则隐藏掉 function _closeAllDropDown(all_node_label,all_node_ul)&#123; document.onclick = function(event)&#123; for(var i = 0 ; i &lt; all_node_label.length ;i++)&#123; if(event.target==all_node_ul[i]||event.target!=all_node_label[i])&#123; all_node_ul[i].style.display=&quot;none&quot;; &#125;else&#123; all_node_ul[i].style.display=&quot;block&quot;; &#125; &#125; &#125; &#125; //开放出去 CustomComponent.prototype.dropDown=&#123; init:_init &#125;;&#125;)(CustomComponent)//component.jsfunction Customponent()&#123;&#125;var custComponent=new Customponent();","tags":[{"name":"component","slug":"component","permalink":"https://guimeisang.github.io/tags/component/"}]},{"title":"常用的git入门命令行","date":"2016-12-16T01:57:16.000Z","path":"2016/12/16/常用的git入门命令行/","text":"Git远程操作详细详细如下：本文详细介绍了5个基本的git命令 git clone git remote git fetch git pull git push 本文只是针对git初级用户，这不包括完全小白，如果是完全明白，基本上是可以覆盖所有的普通的操作！ 一、git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 1$ git clone &lt;版本库的网址&gt; 比如：克隆jQuery的版本库。 1$ git clone https://github.com/jquery/jquery.git git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 1234567$ git clone http[s]://example.com/path/to/repo.git/$ git clone ssh://example.com/path/to/repo.git/$ git clone git://example.com/path/to/repo.git/$ git clone /opt/git/project.git$ git clone file:///opt/git/project.git$ git clone ftp[s]://example.com/path/to/repo.git/$ git clone rsync://example.com/path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 二、git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。 12$ git remoteorigin 使用-v选项，可以参看远程主机的网址。 123$ git remote -vorigin git@github.com:jquery/jquery.git (fetch)origin git@github.com:jquery/jquery.git (push) 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 123$ git clone -o jQuery https://github.com/jquery/jquery.git$ git remotejQuery git remote show命令加上主机名，可以查看该主机的详细信息。 1$ git remote show &lt;主机名&gt; git remote add命令用于添加远程主机。 1$ git remote add &lt;主机名&gt; &lt;网址&gt; git remote rm命令用于删除远程主机。 1$ git remote rm &lt;主机名&gt; git remote rename命令用于远程主机的改名。 1$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; 三、git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到==git fetch==命令。 1$ git fetch &lt;远程主机名&gt; 上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 比如，取回origin主机的master分支。 1$ git fetch origin master 所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 123456$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 1$ git checkout -b newBrach origin/master 上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 123$ git merge origin/master# 或者$ git rebase origin/master 上面命令表示在当前分支上，合并origin/master。 四、git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 请自行都用一遍，力争理解到本地仓库和远程仓库，index，本地工作区的之间是怎么联系的。 这个主要是参考blog","tags":[{"name":"git cli","slug":"git-cli","permalink":"https://guimeisang.github.io/tags/git-cli/"}]},{"title":"正式开发中的版本管理","date":"2016-12-16T01:56:48.000Z","path":"2016/12/16/正式开发中的版本管理/","text":"Git分支管理 在正式开发中，以下会就几个比较典型的情况进行详细指导 详细如下：版本的分支(branch)和合并（merge）是否方便。有代码的物理拷贝。但是git只生成一个指向当前版本的指针(header)；这个就是得git很方便但是这个好处会带来一些不便之处：就是你不加注意的话，很有可能会留下一个枝节曼生/四处开放的版本库。到处都是分支的脉络。下面有一种策略，它可以使得版本库演进保持简洁，主干清晰，各分支清晰各司其职，井井有条。 ## 一、主分支Master首先，代码库应该有一个，且有一个主分支。所有提供用户使用的正式版本，都在这个主分支上面发布。 Git主分支的名字，默认叫做Master，它是自动建立的。版本库初始化以后，默认就是在主干上面开发。 二、开发分支dev主分支主要是用来分布重大版本，日常开发应该在另一条分支上面完成的。我们把开发叫做dev 这个分支可以用来生成代码的最新隔夜版本(nightly)。如果是想正式对外发布，就在Master分支上，把master分之合并到dev（此时dev已经提前几个commit了） Git创建dev分支1git checkout -b dev master 然后你就在dev上面，写你的代码，写完之后，git add &lt;你的文件&gt; → git commit -m “记录” → git push。开发完之后将dev分支发布到Master分支的命令：1234# 切换到Master分支git checkout master# 对Develop分支进行合并（--no-ff参数代表着:Git执行&quot;快进式合并&quot;（fast-farward merge），会直接将Master分支指向Develop分支）git merge --no-ff dev -m &quot;将master分支merge到dev上去&quot; 在master分支上面merge完之后，还需要，对merge的文件进行 git commit和git push 命令！ 使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的 《Understanding the Git Workflow》 三、临时性分支前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。 但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种： 功能（feature）分支 预发布（release）分支 修补bug（fixbug）分支这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。 四、 功能分支接下来，一个个来看这三种”临时性分支”。第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。 功能分支的名字，可以采用feature-*的形式命名。创建一个功能分支：1git checkout -b feature-x develop 在feature-x分支上开发完成后()，将功能分支合并到develop分支：12git checkout developgit merge --no-ff feature-x merge之后再dev分支上，git commit 和git push 将最新的文件push上去。删除feature分支：1git branch -d feature-x 预发布分支第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。 创建一个预发布分支：1git checkout -b release-1.2 develop 确认没有问题后，合并到master分支：1234git checkout mastergit merge --no-ff release-1.2# 对合并生成的新节点，做一个标签git tag -a 1.2 再合并到develop分支：12 git checkout develop git merge --no-ff release-1.2 记得在master和dev上面，将更新的文件commmit和push上去最后，删除预发布分支：1git branch -d release-1.2 ## 六、修补bug分支最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。 创建一个修补bug分支： 1git checkout -b fixbug-0.1 master 修补结束后，合并到master分支： 123git checkout mastergit merge --no-ff fixbug-0.1git tag -a 0.1.1 再合并到develop分支： 12git checkout developgit merge --no-ff fixbug-0.1 最后，删除”修补bug分支”： 1git branch -d fixbug-0.1 (完) 七、重命名远程分支 在开发中，我们需要管理好自己的分支。 有一种场景就是本来在dev分支进行开发的，但是为了区别版本号，需要将dev改成v1.2.0版本 解决的思路就是：先删除远程的分支，然后重命名本地分支，再重新提交一个远程分支。 先查一下所以的分支1234567$ git branch -av* dev c38c6b2 异步加载，缓存 commit master b70dd0f 有问题的文件上传做个提示... remotes/origin/HEAD -&gt; origin/master remotes/origin/dev c38c6b2 异步加载，缓存 commit remotes/origin/master b70dd0f 有问题的文件上传做个提示... remotes/origin/release-v1.1.0 b70dd0f 有问题的文件上传做个提示... 删除远程分支 123$ git push --delete origin devTo https://xxx.com/xxx/xxx.git - [deleted] dev 重命名本地分支： 1git branch -m devel dev-v1.2.0 推送本地分支： 12345678910111213$ git push origin dev-v1.2.0Counting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (13/13), done.Writing objects: 100% (20/20), 3.79 KiB | 0 bytes/s, done.Total 20 (delta 8), reused 19 (delta 7)remote:remote: Create merge request for dev-v1.2.0:remote: https://xxx/merge_requests/new?merge_request%5Bsource_branch%5D=dev-v1.2.0remote:To https://xxx.git * [new branch] dev-v1.2.0 -&gt; dev-v1.2.0 再查看下所有的branch情况 123456* dev-v1.2.0 c38c6b2 异步加载，缓存 commit master b70dd0f 有问题的文件上传做个提示... remotes/origin/HEAD -&gt; origin/master remotes/origin/dev-v1.2.0 c38c6b2 异步加载，缓存 commit remotes/origin/master b70dd0f 有问题的文件上传做个提示... remotes/origin/release-v1.1.0 b70dd0f 有问题的文件上传做个提示... 在删除远程分支的时候，容易碰到的问题就是如下： 12345$ git push --delete origin develremote: error: refusing to delete the current branch: refs/heads/develTo git@github.com:zrong/quick-cocos2d-x.git ! [remote rejected] devel (deletion of the current branch prohibited)error: failed to push some refs to &apos;git@github.com:zrong/quick-cocos2d-x.git&apos; 这是由于在 github 中，devel 是项目的默认分支。要解决此问题，这样操作： 进入 github 中该项目的 Settings 页面； 设置 Default Branch 为其他的分支（例如 master）； 重新执行删除远程分支命令。 该文主要参考blog","tags":[{"name":"git cli","slug":"git-cli","permalink":"https://guimeisang.github.io/tags/git-cli/"}]},{"title":"周日学做菜","date":"2015-12-18T15:51:26.000Z","path":"2015/12/18/周日学做菜/","text":"三个菜.jpg 周末表妹过来她依旧如此美丽，却多了些贤惠和能干 鸡爪和萍乡小炒肉她炒的说是来尝我的菜，结果我就做了一个白菜很是不太好意思 脑子里现在过一下从选材到切菜，配料，下锅萍乡小炒肉，肉切薄点，先用酱油盐卤一下，大蒜切细，葱，蒜叶，干辣椒，生抽鸡爪，先水过一下，筷子可戳动，去掉爪子，切两半 ，炒大蒜和蒜根，放入鸡爪，酱油，干辣椒，生抽 实践才能将知识理论转化为智慧我想做一个有智慧的人你会来试菜吗？","tags":[{"name":"生活","slug":"生活","permalink":"https://guimeisang.github.io/tags/生活/"}]},{"title":"周末生活系列之一","date":"2015-01-08T10:16:33.000Z","path":"2015/01/08/周末生活系列之一/","text":"突然有段时间你会很想学做菜 最近桂梅桑开始痴迷做饭，希望在过年的时候再去看看有什么新的做法，get这些技能。以后就可以自己想吃就可以自己做了 辣椒酱油虾材料： 辣椒（可以根据想吃的辣度，我一般喜欢比较辣的），蒜头，大蒜叶，老姜，8两虾米（两三人的量），酱油，鱼鼓油（李锦记的），鸡精。 步骤： 先将虾用滚热的水过一次，虾米变红为止（里面必须切大片的姜去腥） 将辣椒，蒜头，老姜，蒜叶先切好 放油，先将辣椒，蒜头，老姜等比较硬的作料炒出香味。 放虾（此间只要是或有点大，有烧焦的迹象，就放入点酱油，鱼鼓油，放盐巴，鸡精等。） 在出锅的时候，放入大蒜叶。 然后放点酱油和醋做蘸料就可以开吃啦 家常油豆腐材料：辣椒（建议辣点），蒜头，蒜叶，等 步骤： 放入大蒜，辣椒爆炒（火小点） 将油豆腐用水洗一下，然后对半切 放入油豆腐炒下，放入酱油，鸡精等 放水，盐巴，煮一下。 出锅时，放入蒜叶翻炒即可 生活用美味点缀，很美妙…","tags":[{"name":"周末生活系列","slug":"周末生活系列","permalink":"https://guimeisang.github.io/tags/周末生活系列/"}]}]